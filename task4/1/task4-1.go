package main

import (
	"fmt"
	"log"
	"math/rand"
	"os"
	"os/signal"
	"sync"
	"syscall"
)

func main() {
	log.Println("Введите количество воркеров")
	var numWorkers int

	// Считываем количество воркеров из консоли
	fmt.Scan(&numWorkers)

	// Поскольку параллельная работа воркеров возможна только в горутинах, то
	// следует организовать waitGroup для главной вызывающей горутины,
	// которая должна дождаться корректного завершения всех воркеров.
	// Сигналом к закрытию может послужить как минимум 2 варианта.
	// 1. Передача сигнала о закрытии через переменную.
	// В этом случае нам нужно передать сигнал в каждый воркер
	// и воркере организовать его прослушивание.
	// При получении сигнала - завершить работу воркера, не забыв
	// сказать об этом вызывающей горутине функцией wg.Done
	// Не самый удобный способ - фантазия у всех разная и имя этой переменной может быть разным.
	// Да ещё таскать с собой везде указатель на эту переменную....
	// 2. Второй вариант
	// создать контекст и передавать в каждый воркер не созданную кем-то непонятную переменную,  а всем понятный контекст
	// В данном случае в воркере будет организовано прослушивание контеста
	// При поступлении сигнала о закрытии программы мы отменим все дочерние контексты
	// Сигнал к закрытию поимает воркер и выполнит корректное завершение wg.Done

	log.Println("===== Пример 1 =====")
	var sig = false
	go func() {
		chlClose := make(chan os.Signal)
		signal.Notify(chlClose, os.Interrupt, syscall.SIGQUIT, syscall.SIGABRT, syscall.SIGTERM)
		for {
			if sig {
				break
			}
			select {
			// организуем прослушивание сигналов закрытия
			case <-chlClose:
				log.Println("Получен сигнал останова от операционной системы, завершаю работу ...")
				sig = true

			}
		}
	}()

	// Создадим канал, в который основная горутина будет слать данные.
	data := make(chan int32)
	// Создадим группу ожидания горутин.
	wg := &sync.WaitGroup{}

	// Запустим воркеры которые будут производить чтение из канала
	for i := 0; i < numWorkers; i++ {
		wg.Add(1)
		log.Println(i)
		go worker(data, i, wg, &sig)
	}
	// time.Sleep(15 * time.Second)

	// Теперь организуем запись в канал
	for {
		if sig {
			log.Println("Я Main. Завершаю работу...")
			break
		}
		d := rand.Int31()
		data <- d
		// log.Printf("Я Main. Данные в канал %v: ", d)
	}

	wg.Wait()

	log.Println("Все воркеры остановлены")
	log.Println("Я Main. Работу завершил.")
}

func worker(data chan int32, numWorcker int, wg *sync.WaitGroup, stopSig *bool) {
	for {
		if *stopSig {
			log.Printf("Я воркер № %v. Завершаю работу...", numWorcker)
			break
		}
		select {
		case d := <-data:
			log.Printf("Я воркер № %v. Данные из канала %v: ", numWorcker, d)
		default:

		}
	}

	wg.Done()
	log.Printf("Я воркер № %v. Работу завершил.", numWorcker)
}

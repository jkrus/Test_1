package main

import (
	"log"
	"sync"
)

var wg sync.WaitGroup

func main() {
	// Создадим каналы
	ch1 := make(chan int)
	ch2 := make(chan int)
	array0 := make([]int, 100)

	// Заполним массив числами
	for i := 0; i < 100; i++ {
		array0[i] = i
	}

	// Организуем запуск горутины, которая берёт элементы из массива и передаёт их в канал
	// Для разнообразия я использую здесь однонаправленный канал, чтобы показать
	// что данная горутина может только записывать данные в канал
	wg.Add(1)
	go func(ch <-chan int) {
		for _, a0 := range array0 {
			ch1 <- a0
		}
		close(ch1)
		wg.Done()
	}(ch1)

	// Организуем запуск горутины которая будет читать данные из первого канал и записывать во второй канал
	// результат возведения в квадрат числа из первого канала
	// Здесь я передам в горутину 2 однонаправленных канала, чтобы показать
	// что горутина может только читать данные из первого канала
	// только записывать во второй канал
	wg.Add(1)
	go func(ch1 <-chan int, ch2 chan<- int) {
		for {
			select {
			case queue, ok := <-ch1:
				if !ok {
					close(ch2)
					wg.Done()
					return
				}
				ch2 <- queue * queue
			}
		}

	}(ch1, ch2)

	// Организуем запуск горутины, которая берёт элементы из второго канала и выводит их в консоль
	// Здесь я также передам в горутину однонаправленный канал
	// Из которого горутина сможет только читать данные
	wg.Add(1)
	go func(ch <-chan int) {
		for {
			select {
			case res, ok := <-ch2:
				if !ok {
					wg.Done()
					return
				}
				log.Println(res)
			default:

			}
		}
	}(ch2)

	// Дождёмся окончания работы всех горутин
	wg.Wait()
}

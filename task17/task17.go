package main

import "log"

func main() {
	q := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	f, b := binarySearch(q, 5)
	log.Println(f, " ", b)

}

// Ох, и кривой поиск получился. Но бинарный. Оригинальный, красивее, не работает с индексами.
// В случае успеха при поиске - выведем индекс элемента в массиве и true
// В случае не успеха при поиске - 0 и false
func binarySearch(sortedSlice []int, search int) (int, bool) {
	lenSlice := len(sortedSlice)
	var leftBound, rightBound int = 0, lenSlice
	mid := rightBound / 2
	for {
		// Если у нас левая и правая границы сошлись, значит элемент не найден
		if leftBound >= rightBound {
			return 0, false
		}
		// Если середина диапазона не равна или больше искомого элемента,
		// то будем работать с левой частью исходного диапазона
		if sortedSlice[mid] >= search {
			// Проверим что текущий элемент не равен искомому
			// Если это не так, то левая граница остаётся без изменений, а правой границей станет середина
			// исходного диапазона. Тем самым правая часть исходного диапазона нам больше не интересна.
			if sortedSlice[mid] != search {
				rightBound = mid
				mid /= 2
				continue
			}
			// Если же предыдущая проверка увенчалась не успехом - мы нашли искомый элемент.
			return mid, true
		} else {
			// Если же середина элемент из середины диапазона меньше искомого
			// значит нам нужно искать в правой части диапазона.
			// Изменим левую границу.
			leftBound = mid + 1
			// рассчитаем середину диапазона, исходя из новой левой границы.
			mid = leftBound + (rightBound-leftBound)/2
			// Здесь проверим, не вышли ли мы за границы среза, если это так, то в срезе нет искомого элемента
			if mid >= lenSlice {
				return 0, false
			}
			// Если же текущий средний элемент не равен искомому, то
			// продолжим поиск с обновлёнными границами.
			if sortedSlice[mid] != search {
				continue
			}
			// Если же предыдущая проверка не увенчалась успехом - мы нашли искомый элемент.
			return mid, true
		}
	}
}

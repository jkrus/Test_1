package main

import (
	"log"
	"sync"
	"sync/atomic"
	"time"
)

// Создаём срез чисел. Он проинициализируется при компилляции.
var numbers = []int32{2, 4, 6, 8, 10}

func main() {
	// Для запуска конкурентных вычислений будем использовать горутины.
	// Поскольку горутины попадают в планировщик go, то они не выполняются в момент
	// вызова горутины. Их вызовом управляет планировщик.
	// Для ожидания завершения работы горутин нужно использовать sync. WaitGroup
	// Поскольку итоговая сумма является разделяемым ресурсом, то доступ к ней должен быть упорядочен.
	// Например, можно использовать примитив синхронизации из пакета atomic
	log.Println("===== Пример 1 =====")
	wg := sync.WaitGroup{}
	var sum1 int32
	for _, num := range numbers {
		wg.Add(1)
		// запускаем горутину
		go func(n int32) {
			defer wg.Done()
			n2 := n * n
			log.Printf("%v*%v = %v", n, n, n2)
			// Следующая строка выполняет контроль доступа к разделяемому ресурсу - в нашем случае это переменная sum
			// которая будет одновременно записываться только одной горутиной.
			// Если написать так:
			// sum = sum + n2
			// и если вдруг нам понадобится использовать промежуточный результат суммирования,
			// то результат может значительно отличаться от ожидаемого.
			atomic.AddInt32(&sum1, n2)
		}(num)
	}

	wg.Wait()

	log.Println("Sum1 = ", sum1)

	log.Println("===== Пример 2 =====")

	// Ещё один вариант - можно организовать передачу данных через канал
	// также здесь я буду использовать именованную функцию.

	// создадим буферизированный канал для получения квадрата числа
	ch2 := make(chan int32, len(numbers))
	var sum2 int32

	// Организуем перебор массива чисел
	// За циклом организуем чтение из канала
	for _, n := range numbers {
		wg.Add(1)
		// Важно передавать wg по ссылке - чтобы внутри функции работать не с копией wg
		go square(n, ch2, &wg)
	}
	// Дождёмся что все горутины отработали и закроем канал
	wg.Wait()
	close(ch2)
	// Из закрытого канала мы можем продолжить чтение данных.
	// Цикл прекратится, когда считается последний элемент из канала.
	for {
		n, ok := <-ch2
		if !ok {
			break
		}
		sum2 = sum2 + n
	}

	log.Println("Sum2 = ", sum2)

	log.Println("===== Пример 3 =====")
	// Ещё один вариант - можно организовать чтение из канала не по факту заполнения а во время заполнения.
	// также здесь я буду использовать именованную функцию.

	// создадим буферизитрованный канал для получения квадрата числа
	ch3 := make(chan int32, len(numbers))
	var sum3 int32

	// Выполним функцию которая конкурентно запишет квадраты чисел в канал и закроет его по окончанию работы.
	// Запустим её в горутине,  чтобы сразу перейти к чтению из канала
	go square3(numbers, ch3, &wg)

	// Из закрытого канала мы можем продолжить чтение данных.
	// Цикл прекратится, когда считается последний элемент из канала.
	// Чтение из канала начнётся как только в него поступят первые данне
	// Выведем на экран промежуточную сумму чтобы увидеть, что запись и вычисление суммы происходит параллельно.
	for {
		n, ok := <-ch3
		if !ok {
			break
		}
		sum3 += n
		log.Println("Промежуточная сумма = ", sum3)
	}

	log.Println("Sum3 = ", sum3)
}

func square(n int32, ch chan int32, wg *sync.WaitGroup) {
	defer wg.Done()
	log.Printf("%v*%v = %v", n, n, n*n)
	ch <- n * n
}

func square3(nums []int32, ch chan int32, wg *sync.WaitGroup) {
	// Здесь я объявлю переменную, которая отработает только один раз, чтобы
	// горутина, которая вызвала эту функцию дошла до цикла в котором организовано чтение из канала.
	once := sync.Once{}
	once.Do(func() {
		time.Sleep(3 * time.Second)
	})
	for _, n := range nums {
		wg.Add(1)

		go square(n, ch, wg)
	}
	wg.Wait()

	close(ch)
}
